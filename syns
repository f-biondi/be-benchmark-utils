#!/usr/bin/python3
from sys import argv
import math

class Graph:
    def __init__(self, nodes, partition=None):
        self.edges = []
        self.nodes = nodes
        self.partition = [0] * self.nodes if not partition else partition

    def add_directed_edge(self, start, end):
        self.edges.add((start,end))

    def add_undirected_edge(self, start, end):
        self.add_directed_edge(start, end)
        self.add_directed_edge(end, start)

    def set_partition_block(self, node, block): 
        assert node < nodes
        assert block < nodes
        assert block == node or self.partition[block] == block
        self.partition[node] = block

    def save(self):
        self.edges.sort()
        with open("graph.txt","w") as f:
            f.write(f"{self.nodes}\n")
            f.write(f"{len(self.edges)}\n")
            for e in self.edges:
                f.write(f"{e[0]} {e[1]}\n")
        with open("partition.txt","w") as f:
            for nb in self.partition:
                f.write(f"{nb}\n")

class ChainGraph(Graph):
    def __init__(self, chain_start, size, stable=True):
        super().__init__(nodes, partition=[start] * self.nodes)
        for i in range(chain_start,(chain_start+size) * 4,4):
            if i > chain_start:
                self.add_undirected_edge(i-3, i)
                self.add_undirected_edge(i-1, i+2)
            elif not stable:
                self.set_partition_block(chain_start+1, chain_start+1)
                self.set_partition_block(chain_start+2, chain_start+2)
                self.set_partition_block(chain_start+3, chain_start+3)
            self.add_undirected_edge(i, i+1)
            self.add_undirected_edge(i, i+2)
            self.add_undirected_edge(i+1, i+3)
            self.add_undirected_edge(i+2, i+3)

        chain_end = (size*4) - 1
        self.add_undirected_edge(chain_end, chain_start+2)
        self.add_undirected_edge(chain_end - 2, chain_start)


class SyntheticDoubleChainGraph(Graph):
    def __init__(self, nodes, stable_chain_size, unstable_chain_size):
        super().__init__(nodes)
        self.stable_chain_size = stable_chain_size
        self.unstable_chain_size = unstable_chain_size
        print("Stable chain size:", stable_chain_size, "Unstable Chain size:", unstable_chain_size)

        unstable_chain = ChainGraph(0, unstable_chain_size, stable=False) if unstable_chain_size else Graph(0)
        stable_chain = ChainGraph(unstable_chain_size*4, stable_chain_size) if stable_chain_size else Graph(0)

        self.edges = unstable_chain.edges.extend(stable_chain.edges)
        self.partition = unstable_chain.partition.extend(stable_chain.partition)

if __name__ == "__main__":
    nodes = int(argv[1])
    assert not nodes % 4 and nodes > 0
    ring_n = int(nodes / 4)
    reducibility = float(argv[2])
    assert reducibility >=0 and reducibility <= 1.0
    ring_stable_n = int(ring_n * reducibility)
    ring_unstable_n = int(ring_n - ring_stable_n)
    graph = SyntheticDoubleChainGraph(nodes, ring_stable_n, ring_unstable_n)
    graph.save()
