#!/usr/bin/python3
from sys import argv
import math

class Graph:
    def __init__(self, nodes):
        self.edges = []
        self.nodes = nodes
        self.partition = [0] * self.nodes

    def add_directed_edge(self, start, end):
        self.edges.add((start,end))

    def add_undirected_edge(self, start, end):
        self.add_directed_edge(start, end)
        self.add_directed_edge(end, start)

    def set_partition_block(self, node, block): 
        assert node < nodes
        assert block < nodes
        assert block == node or self.partition[block] == block
        self.partition[node] = block

    def save(self):
        self.edges.sort()
        with open("graph.txt","w") as f:
            f.write(f"{self.nodes}\n")
            f.write(f"{len(self.edges)}\n")
            for e in self.edges:
                f.write(f"{e[0]} {e[1]}\n")
        with open("partition.txt","w") as f:
            for nb in self.partition:
                f.write(f"{nb}\n")

class SyntheticDoubleChainGraph(Graph):
    def __init__(self, nodes, stable_chain_size, unstable_chain_size):
        super().__init__(nodes)
        self.stable_chain_size = stable_chain_size
        self.unstable_chain_size = unstable_chain_size
        print("Stable chain size:", stable_chain_size, "Unstable Chain size:", unstable_chain_size)

        if unstable_chain_size:
            for i in range(0,unstable_chain_size*4,4):
                if i:
                    self.add_undirected_edge(i-3, i)
                    self.add_undirected_edge(i-1, i+2)
                else:
                    self.set_partition_block(1,1)
                    self.set_partition_block(2,2)
                    self.set_partition_block(3,3)
                self.add_undirected_edge(i, i+1)
                self.add_undirected_edge(i, i+2)
                self.add_undirected_edge(i+1, i+3)
                self.add_undirected_edge(i+2, i+3)

            unstable_chain_end = (unstable_chain_size*4) - 1
            self.add_undirected_edge(unstable_chain_end, 2)
            self.add_undirected_edge(unstable_chain_end - 2, 0)

        if stable_chain_size:
            for i in range(unstable_chain_size*4,(unstable_chain_size*4)+(stable_chain_size*4),4):
                if i > (unstable_chain_size*4):
                    self.add_undirected_edge(i-3, i)
                    self.add_undirected_edge(i-1, i+2)
                self.add_undirected_edge(i, i+1)
                self.add_undirected_edge(i, i+2)
                self.add_undirected_edge(i+1, i+3)
                self.add_undirected_edge(i+2, i+3)
                for node in range(i, i+4):
                    self.set_partition_block(node, unstable_chain_size*4)

            stable_chain_end = ((unstable_chain_size*4)+(stable_chain_size*4)) -1
            self.add_undirected_edge(stable_chain_end, (unstable_chain_size*4) + 2)
            self.add_undirected_edge(stable_chain_end-2, (unstable_chain_size*4))

if __name__ == "__main__":
    nodes = int(argv[1])
    assert not nodes % 4
    ring_n = int(nodes / 4)
    reducibility = float(argv[2])
    assert reducibility >=0 and reducibility <= 1.0
    ring_stable_n = int(ring_n * reducibility)
    ring_unstable_n = int(ring_n - ring_stable_n)
    graph = SyntheticDoubleChainGraph(nodes, ring_stable_n, ring_unstable_n)
    graph.save()
