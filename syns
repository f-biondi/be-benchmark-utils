#!/usr/bin/python3
from sys import argv
import math

class Graph:
    def __init__(self, nodes, start=0):
        self.edges = set()
        self.start = start
        self.nodes = nodes
        self.partition = [start] * self.nodes  

    def add_directed_edge(self, start, end):
        self.edges.add((start,end))

    def add_undirected_edge(self, start, end):
        self.add_directed_edge(start, end)
        self.add_directed_edge(end, start)

    def set_partition_block(self, node, block): 
        assert node < nodes
        assert block < nodes
        assert block == node or self.partition[block] == block
        self.partition[node] = block

    def get_node_index(self, node):
        assert node < nodes
        return self.start + node

    def save(self):
        sorted_edges = sorted(list(self.edges))
        with open("graph.txt","w") as f:
            f.write(f"{self.nodes}\n")
            f.write(f"{len(sorted_edges)}\n")
            for e in sorted_edges:
                f.write(f"{e[0]} {e[1]}\n")
        with open("partition.txt","w") as f:
            for nb in self.partition:
                f.write(f"{nb}\n")

class ChainGraph(Graph):
    def __init__(self, chain_start, size):
        super().__init__(nodes, start=chain_start)
        for i in range(0, size*4, 4):
            self.add_undirected_edge(self.get_node_index((i-3) % (size*4)), self.get_node_index(i))
            self.add_undirected_edge(self.get_node_index((i-1) % (size*4)), self.get_node_index(i+2))
            self.add_undirected_edge(self.get_node_index(i), self.get_node_index(i+1))
            self.add_undirected_edge(self.get_node_index(i), self.get_node_index(i+2))
            self.add_undirected_edge(self.get_node_index(i+1), self.get_node_index(i+3))
            self.add_undirected_edge(self.get_node_index(i+2), self.get_node_index(i+3))

class ChainIntraconnectedGraph(ChainGraph):
    def __init__(self, chain_start, size, degree):
        assert degree < size
        super().__init__(chain_start, size)
        self.degree = degree
        for i in range(0, size*4,4):
            for k in range(degree):
                dest_chain_start = self.get_node_index((i + (k*4)) % (size*4))
                self.add_undirected_edge(self.get_node_index((i-3) % (size*4)), dest_chain_start)
                self.add_undirected_edge(self.get_node_index((i-1) % (size*4)), dest_chain_start+2)
                self.add_undirected_edge(self.get_node_index(i), dest_chain_start+1)
                self.add_undirected_edge(self.get_node_index(i), dest_chain_start+2)
                self.add_undirected_edge(self.get_node_index(i+1), dest_chain_start+3)
                self.add_undirected_edge(self.get_node_index(i+2), dest_chain_start+3)

class SyntheticGraph(Graph):
    def __init__(self, nodes, stable_chain_size, unstable_chain_size, degree):
        super().__init__(nodes)
        self.stable_chain_size = stable_chain_size
        self.unstable_chain_size = unstable_chain_size
        self.degree = degree
        unstable_chain = ChainIntraconnectedGraph(0, unstable_chain_size, degree) if unstable_chain_size else Graph(0)
        if unstable_chain_size:
            unstable_chain.set_partition_block(1, 1)
            unstable_chain.set_partition_block(2, 2)
            unstable_chain.set_partition_block(3, 3)
        stable_chain = ChainIntraconnectedGraph(unstable_chain_size * 4, stable_chain_size, degree) if stable_chain_size else Graph(0, start=unstable_chain_size*4)

        self.edges = unstable_chain.edges.union(stable_chain.edges)
        self.partition = unstable_chain.partition + stable_chain.partition

if __name__ == "__main__":
    nodes = int(argv[1])
    assert not nodes % 4 and nodes > 0
    ring_n = int(nodes / 4)
    reducibility = float(argv[2])
    assert reducibility >=0 and reducibility <= 1.0
    ring_stable_n = int(ring_n * reducibility)
    ring_unstable_n = int(ring_n - ring_stable_n)
    n_chain = int(argv[3])
    graph = SyntheticGraph(nodes, ring_stable_n, ring_unstable_n, n_chain)
    graph.save()
